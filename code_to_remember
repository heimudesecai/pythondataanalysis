list1.index('abcde') #get the index of 'abcde' in list1

list1[::-1] #inverse list1. Don't change list1
list1.reverse() #reverse list1 inplace

pd.read_csv('file', sep='|', names=columns, index_col='movie_id', encoding="ISO-8859-1")

sorted(dict1.items(), key= lambda k: k[1]) #sort dict1 based on the value. return list of tuple
sorted(dict1, key= lambda k: k[1]) #sort dict1 based on the value. return list of key
df1.sort_values('year', ascending=True) #dataframe sort based on 'year'

df1.dropna(subset=['year'], inplace=False) #delete rows whose 'year' is nan

df1[df1["year"].isin(list1)] #select rows whose 'year' in list1

pd.DatetimeIndex(df1['date']) #change 'date' column to 'datetime64[ns]' type
pd.DatetimeIndex(df1['date'].fillna(0)).year.astype(int) # get year from 'date' and change it to int type
pd.to_datetime(df1["timestamp"], unit = "s") # change 'timestamp' to datetime64[ns] type
pd.to_datetime(df1["timestamp"], unit = "s").dt.year # df1['timestamp'] is # of seconds since 1970. Change it to date and get the year

df.rename(columns={'col1': "col2"}, inplace = True) #change the name of one column

df1.groupby('col1').agg(['min', 'max']) #group by col1. calculate 'min' and 'max' of all other columns
df1.groupby('col1').col2.agg(['count', 'mean']) #group by col1. calculate 'count' and 'mean' of col2
df1.groupby('col1').col2.agg({'col2_count': 'count', 'col2_mean': 'mean'}) #define the column name
df1.groupby('col1').agg({'col2': ['min', 'max'], 'col3': min})

df1.pivot_table(index = 'col1', columns = 'col2', values = 'col3', aggfunc = 'max', fill_value = 0) 
#All distinct values of col1 become index. All distinct values of col2 become column name. Values are col3.

different multiply
(1) A * B, np.multiply(A, B)
- vector: element wise
- matrix: element wise
(2) A @ B, np.dot(A, B)
- vector: element-wise and sum
- matrix: linear algebra multiply

sparse matrix
X_sparse = sp.coo_matrix([[5., 0., 0.], [1., 1., 0.]])
sp.coo_matrix(([-np.inf] * X_sparse.data.shape[0], (X_sparse.row, X_sparse.col)), shape = X_sparse.shape)
output: matrix([[-inf,   0.,   0.],
                [-inf, -inf,   0.]])
X_sparse.data: all data in X_sparse that is not 0
X_sparse.row, X_sparse.col: the row and col of data in X_sparse

(1) sp.coo_matrix: data, column index, row index
(2) sp.csc_matrix
>>> indptr = np.array([0, 2, 3, 6]) #data[0:2] -> col0; data[2:3] -> col1; data[3:6] -> col2
>>> indices = np.array([0, 2, 2, 0, 1, 2])
>>> data = np.array([1, 2, 3, 4, 5, 6])
>>> sparse.csc_matrix((data, indices, indptr), shape=(3, 3)).toarray()
array([[1, 0, 4],
       [0, 0, 5],
       [2, 3, 6]])
(3) sp.csr_matrix   
>>> indptr = np.array([0, 2, 3, 6]) #data[0:2] -> row0; data[2:3] -> row1; data[3:6] -> row2
>>> indices = np.array([0, 2, 2, 0, 1, 2])
>>> data = np.array([1, 2, 3, 4, 5, 6])
>>> sparse.csr_matrix((data, indices, indptr), shape=(3, 3)).toarray()
array([[1, 0, 2],
       [0, 0, 3],
       [4, 5, 6]])

X_csc.getcol(j).A.ravel() #.getcol(j) get the jth column. .A convert to array. .ravel convert matrix to vector
